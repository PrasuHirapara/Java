
# Java Reflection API

## What is Reflection in Java?

1. **Dynamic Inspection**: Reflection allows inspection and manipulation of classes, methods, fields, and constructors at runtime.
2. **Metadata Access**: It enables access to metadata, such as class structure, methods, fields, and constructors.
3. **Runtime Modification**: Reflection can dynamically change the behavior of code, even accessing private members.
4. **Framework Development**: Often used in frameworks (e.g., Spring, Hibernate) to handle dynamic processing.
5. **Powerful yet Risky**: Although powerful, it has performance impacts and security risks when misused.

## Usage of Java Reflection

- **Testing Frameworks**: Often used in unit testing frameworks like JUnit.
- **Dependency Injection**: Used in frameworks like Spring to inject dependencies dynamically.
- **Serialization and Deserialization**: Provides access to fields even when private.
- **Dynamic Method Invocation**: Allows method invocation without hardcoding method names.

## Disadvantages of Reflection

- **Performance Overhead**: Reflection is slower as it bypasses compile-time optimizations.
- **Security Restrictions**: Requires permissions to access private members, which may not be granted in all environments.
- **Complexity**: Makes code harder to understand, maintain, and debug.
- **Compile-time Safety**: No compile-time type checking for reflected code, which increases runtime errors.

---

## Important Java Reflection Methods

### Class Methods

1. `getName()` - Returns the name of the class.
2. `getSuperclass()` - Returns the superclass of the class.
3. `getInterfaces()` - Returns an array of interfaces implemented by the class.
4. `getModifiers()` - Returns the access modifiers of the class.
5. `getPackage()` - Returns the package to which the class belongs.
6. `isAnnotationPresent()` - Checks if an annotation is present on the class.
7. `isInterface()` - Checks if the class is an interface.
8. `isEnum()` - Checks if the class is an enum.
9. `getFields()` - Returns public fields of the class.
10. `getDeclaredFields()` - Returns all fields (public, protected, private) of the class.
11. `getMethods()` - Returns public methods of the class.
12. `getDeclaredMethods()` - Returns all methods (public, protected, private) of the class.
13. `getConstructors()` - Returns public constructors of the class.
14. `getDeclaredConstructors()` - Returns all constructors (public, private, protected) of the class.
15. `cast(Object obj)` - Casts an object to the class represented by this Class object.

### Field Methods

1. `getName()` - Returns the name of the field.
2. `getType()` - Returns the type of the field.
3. `getModifiers()` - Returns the access modifiers of the field.
4. `isAccessible()` - Checks if the field is accessible.
5. `setAccessible(boolean flag)` - Sets the accessibility of the field.
6. `get(Object obj)` - Returns the value of the field for a specific object.
7. `set(Object obj, Object value)` - Sets a new value for the field in the specified object.
8. `isEnumConstant()` - Checks if the field is an enum constant.
9. `getAnnotatedType()` - Returns the annotated type of the field.
10. `getDeclaredAnnotations()` - Returns annotations on the field.
11. `isSynthetic()` - Checks if the field is synthetic.
12. `getGenericType()` - Returns the generic type of the field.
13. `isAnnotationPresent(Class<? extends Annotation> annotationClass)` - Checks if the field has a specified annotation.
14. `getAnnotations()` - Returns all annotations of the field.
15. `getDeclaredAnnotationsByType()` - Returns annotations by type on the field.

---

### Constructor Methods

1. `getName()` - Returns the name of the declaring class for the constructor.
2. `getParameterTypes()` - Returns an array of `Class` objects representing the parameter types of the constructor.
3. `getModifiers()` - Returns the access modifiers of the constructor.
4. `isAccessible()` - Checks if the constructor is accessible.
5. `setAccessible(boolean flag)` - Sets the accessibility of the constructor.
6. `newInstance(Object... initargs)` - Creates a new instance of the declaring class, using the constructor with specified arguments.
7. `getExceptionTypes()` - Returns an array of `Class` objects representing the exception types declared to be thrown by the constructor.
8. `isVarArgs()` - Checks if the constructor takes a variable number of arguments.
9. `getParameterCount()` - Returns the number of parameters the constructor accepts.
10. `getDeclaredAnnotations()` - Returns all annotations declared on this constructor.
11. `isSynthetic()` - Checks if the constructor is synthetic (i.e., generated by the compiler).
12. `getAnnotatedReturnType()` - Returns the annotated return type of the constructor.
13. `getAnnotationsByType(Class<T> annotationClass)` - Returns an array of annotations of a specified type on the constructor.
14. `toGenericString()` - Returns a string representation of the constructor with generic types.
15. `isAnnotationPresent(Class<? extends Annotation> annotationClass)` - Checks if a specific annotation is present on the constructor.

---

### Student class
```java
package Reflection;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;

public class Student {
    private final String name;
    private int age;
    static int total = 0;

    // Constructor
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
        total++;
    }

    // Getters and Setters
    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public static int getTotal() {
        return total;
    }

    // Private method
    private void privatePrint() {
        System.out.println("Private method: print. Name = " + this.name);
    }

    // Static method
    public static void publicStaticPrint() {
        System.out.println("Public method: print. Total = " + total);
    }
}

```

### Main class
```java
package Reflection;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.Modifier;
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        // Instantiate Student object and get its Class
        Student student = new Student("Prasu", 19);
        Class<?> studentClass = student.getClass();
        String className = studentClass.getName();
        System.out.println("Class Name: " + className);

        // Print all fields, including private fields
        Field[] fields = studentClass.getDeclaredFields();
        System.out.println("Fields: " + Arrays.toString(fields));
        for (Field field : fields) {
            field.setAccessible(true); // Make private fields accessible
            System.out.println("Field Name: " + field.getName());
            System.out.println("Field Type: " + field.getType());

            // Modify and access specific fields
            try {
                if (field.getName().equals("name")) {
                    field.set(student, "Prasu Updated");
                    System.out.println("Updated Name: " + field.get(student));
                }
                if (field.getName().equals("age")) {
                    field.setInt(student, 20);
                    System.out.println("Updated Age: " + field.get(student));
                }
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            }
        }

        // List and invoke public methods
        System.out.println("\nPublic Methods:");
        Method[] methods = studentClass.getMethods();
        for (Method method : methods) {
            System.out.println("Method Name: " + method.getName());
            System.out.println("Return Type: " + method.getReturnType());
            System.out.println("Parameters: " + Arrays.toString(method.getParameterTypes()));

            // Invoke static method
            if (method.getName().equals("publicStaticPrint")) {
                try {
                    method.invoke(null);
                } catch (IllegalAccessException | InvocationTargetException e) {
                    e.printStackTrace();
                }
            }
        }

        // Access private method and invoke it
        try {
            Method privateMethod = studentClass.getDeclaredMethod("privatePrint");
            privateMethod.setAccessible(true);
            privateMethod.invoke(student);
        } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException e) {
            e.printStackTrace();
        }

        // Print constructors
        System.out.println("\nConstructors:");
        Constructor<?>[] constructors = studentClass.getConstructors();
        for (Constructor<?> cons : constructors) {
            System.out.println("Constructor: " + cons);
            System.out.println("Parameters: " + Arrays.toString(cons.getParameterTypes()));
        }

        // Print class modifiers
        System.out.println("\nClass Modifiers: " + Modifier.toString(studentClass.getModifiers()));
        System.out.println("Is Public: " + Modifier.isPublic(studentClass.getModifiers()));

        // List interfaces implemented by Student
        Class<?>[] interfaces = studentClass.getInterfaces();
        System.out.println("Interfaces: " + Arrays.toString(interfaces));
    }
}
```
---

## Usage in Spring Boot
- **Dependency Injection**: Springâ€™s dependency injection mechanism often relies on Reflection to inject fields dynamically, including private ones.
- **Bean Instantiation**: During application startup, Spring Boot uses Reflection to instantiate beans and configure properties without explicit constructor calls.
- **Configuration Processing**: Reflection helps process configuration metadata, enabling Spring Boot to auto-configure components and inject dependencies.
- **Annotation Handling**: Spring Boot uses Reflection to process custom annotations, applying logic based on their presence on classes, methods, or fields.
- **AOP (Aspect-Oriented Programming)**: Reflection enables AOP by injecting behavior (e.g., logging, transaction management) into methods at runtime.

---

